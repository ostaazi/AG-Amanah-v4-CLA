import {
  Timestamp,
  addDoc,
  collection,
  doc,
  getDoc,
  getDocs,
  limit,
  onSnapshot,
  orderBy,
  query,
  setDoc,
  where,
} from 'firebase/firestore';
import { db } from './firebaseConfig';
import { is2FAEnabled } from './twoFAService';
import {
  scanParentAndroidSecuritySurface,
  type ParentAndroidSecurityFinding,
} from './parentAndroidSecurityService';

export interface DeviceVulnerabilityFindingRecord {
  childId: string;
  parentId: string;
  childName: string;
  scanTimestamp?: Date;
  trigger?: string;
  riskScore?: number;
  topSeverity?: string;
  criticalCount?: number;
  highCount?: number;
  findings?: Array<Record<string, any>>;
}

export interface ParentVulnerabilityFinding {
  id: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  titleEn: string;
  titleAr: string;
  detailEn: string;
  detailAr: string;
  remediationMode: 'AUTO' | 'GUIDED';
  guidanceEn: string;
  guidanceAr: string;
  autoAction?: {
    type: 'OPEN_SETTING';
    target: string;
  };
}

export interface ParentVulnerabilityScanSnapshot {
  parentId: string;
  scannedAt?: Date;
  scannedAtMs?: number;
  browserFamily?: string;
  browserMajor?: number | null;
  secureContext?: boolean;
  protocol?: string;
  riskScore?: number;
  findings: ParentVulnerabilityFinding[];
  nativeScanAvailable?: boolean;
  nativeRiskScore?: number;
  deviceSummary?: {
    apiLevel?: number;
    osVersion?: string;
    securityPatchLevel?: string;
    deviceModel?: string;
    isDeviceOwner?: boolean;
  };
  watchlist?: Array<{
    advisoryId: string;
    title: string;
    platform: 'android' | 'browser' | 'cross-platform';
    riskType: 'zero-click' | 'zero-day';
  }>;
}

export type VulnerabilityHistoryEventType = 'SCAN' | 'REMEDIATION' | 'UNDO';
export type VulnerabilityHistoryTarget = 'PARENT' | 'CHILD';
export type VulnerabilityHistoryStatus = 'SUCCESS' | 'FAILED' | 'INFO';
export type VulnerabilityHistoryActionKind = 'SCAN' | 'COMMAND' | 'OPEN_SETTING';

export interface VulnerabilityHistoryEntry {
  id: string;
  parentId: string;
  target: VulnerabilityHistoryTarget;
  childId?: string;
  childName?: string;
  eventType: VulnerabilityHistoryEventType;
  actionKind: VulnerabilityHistoryActionKind;
  status: VulnerabilityHistoryStatus;
  scanTimestamp?: Date;
  scanTimestampMs: number;
  riskScore?: number;
  topSeverity?: string;
  severity?: string;
  findingId?: string;
  titleEn?: string;
  titleAr?: string;
  summaryEn?: string;
  summaryAr?: string;
  command?: string;
  payload?: any;
  undoAvailable: boolean;
  undoCommand?: string;
  undoPayload?: any;
  actor?: string;
  metadata?: Record<string, any>;
}

export interface VulnerabilityHistoryEventInput {
  target: VulnerabilityHistoryTarget;
  childId?: string;
  childName?: string;
  eventType: VulnerabilityHistoryEventType;
  actionKind: VulnerabilityHistoryActionKind;
  status: VulnerabilityHistoryStatus;
  scanTimestampMs?: number;
  riskScore?: number;
  topSeverity?: string;
  severity?: string;
  findingId?: string;
  titleEn?: string;
  titleAr?: string;
  summaryEn?: string;
  summaryAr?: string;
  command?: string;
  payload?: any;
  undoCommand?: string;
  undoPayload?: any;
  actor?: string;
  metadata?: Record<string, any>;
}

export interface UndoCommandInstruction {
  command: string;
  payload: any;
}

const CHILD_FINDINGS_COLLECTION = 'vulnerabilityFindings';
const PARENT_FINDINGS_COLLECTION = 'parentVulnerabilityFindings';
const HISTORY_SUBCOLLECTION = 'history';

const ZERO_DAY_WATCHLIST: Array<{
  advisoryId: string;
  title: string;
  platform: 'android' | 'browser' | 'cross-platform';
  riskType: 'zero-click' | 'zero-day';
}> = [
  {
    advisoryId: 'WATCH-ANDROID-MSG-RCE',
    title: 'Remote code execution chain observed in mobile messaging surfaces',
    platform: 'android',
    riskType: 'zero-click',
  },
  {
    advisoryId: 'WATCH-ANDROID-PRIV-ESC',
    title: 'Privilege escalation exploit targeting outdated Android patch levels',
    platform: 'android',
    riskType: 'zero-day',
  },
  {
    advisoryId: 'WATCH-BROWSER-SANDBOX-ESCAPE',
    title: 'Browser sandbox escape campaign against lagging browser versions',
    platform: 'browser',
    riskType: 'zero-day',
  },
];

const resolveExternalWatchlistUrl = (): string => {
  return String(import.meta.env.VITE_VULNERABILITY_FEED_URL || '').trim();
};

const fetchExternalWatchlist = async (): Promise<
  Array<{
    advisoryId: string;
    title: string;
    platform: 'android' | 'browser' | 'cross-platform';
    riskType: 'zero-click' | 'zero-day';
  }>
> => {
  const url = resolveExternalWatchlistUrl();
  if (!url) return [];
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 4000);
    const response = await fetch(url, {
      method: 'GET',
      headers: { Accept: 'application/json' },
      signal: controller.signal,
    });
    clearTimeout(timeout);
    if (!response.ok) return [];
    const payload = await response.json();
    if (!Array.isArray(payload)) return [];
    return payload
      .map((item: any) => ({
        advisoryId: String(item?.advisoryId || '').trim(),
        title: String(item?.title || '').trim(),
        platform: item?.platform === 'browser' || item?.platform === 'cross-platform' ? item.platform : 'android',
        riskType: item?.riskType === 'zero-click' ? 'zero-click' : 'zero-day',
      }))
      .filter((item) => item.advisoryId && item.title)
      .slice(0, 20);
  } catch {
    return [];
  }
};

const parseBrowserVersion = (ua: string): { family: string; major: number | null } => {
  const normalized = ua.toLowerCase();
  const extract = (pattern: RegExp): number | null => {
    const match = ua.match(pattern);
    return match ? Number(match[1]) : null;
  };

  if (normalized.includes('edg/')) {
    return { family: 'edge', major: extract(/Edg\/(\d+)/) };
  }
  if (normalized.includes('chrome/') && !normalized.includes('edg/')) {
    return { family: 'chrome', major: extract(/Chrome\/(\d+)/) };
  }
  if (normalized.includes('firefox/')) {
    return { family: 'firefox', major: extract(/Firefox\/(\d+)/) };
  }
  if (normalized.includes('safari/') && normalized.includes('version/')) {
    return { family: 'safari', major: extract(/Version\/(\d+)/) };
  }
  return { family: 'unknown', major: null };
};

const addFinding = (
  findings: ParentVulnerabilityFinding[],
  finding: ParentVulnerabilityFinding
) => {
  findings.push(finding);
};

const buildHistoryPayload = (
  parentId: string,
  event: VulnerabilityHistoryEventInput
) => {
  const tsMs = event.scanTimestampMs ?? Date.now();
  return {
    parentId,
    target: event.target,
    childId: event.childId || null,
    childName: event.childName || '',
    eventType: event.eventType,
    actionKind: event.actionKind,
    status: event.status,
    scanTimestamp: Timestamp.fromMillis(tsMs),
    scanTimestampMs: tsMs,
    riskScore: typeof event.riskScore === 'number' ? event.riskScore : null,
    topSeverity: event.topSeverity || null,
    severity: event.severity || null,
    findingId: event.findingId || null,
    titleEn: event.titleEn || null,
    titleAr: event.titleAr || null,
    summaryEn: event.summaryEn || null,
    summaryAr: event.summaryAr || null,
    command: event.command || null,
    payload: event.payload ?? null,
    undoAvailable: Boolean(event.undoCommand),
    undoCommand: event.undoCommand || null,
    undoPayload: event.undoPayload ?? null,
    actor: event.actor || null,
    metadata: event.metadata || null,
  };
};

const mapHistoryEntry = (
  id: string,
  data: any,
  fallbackTarget: VulnerabilityHistoryTarget
): VulnerabilityHistoryEntry => {
  const scanTs = data?.scanTimestamp?.toDate?.() || data?.timestamp?.toDate?.() || undefined;
  const scanTsMs =
    typeof data?.scanTimestampMs === 'number'
      ? data.scanTimestampMs
      : scanTs?.getTime?.() || Date.now();
  const target = (data?.target as VulnerabilityHistoryTarget) || fallbackTarget;
  const rawEventType = String(data?.eventType || '').toUpperCase();
  const eventType: VulnerabilityHistoryEventType =
    rawEventType === 'REMEDIATION' || rawEventType === 'UNDO' || rawEventType === 'SCAN'
      ? (rawEventType as VulnerabilityHistoryEventType)
      : 'SCAN';
  const rawActionKind = String(data?.actionKind || '').toUpperCase();
  const actionKind: VulnerabilityHistoryActionKind =
    rawActionKind === 'COMMAND' || rawActionKind === 'OPEN_SETTING' || rawActionKind === 'SCAN'
      ? (rawActionKind as VulnerabilityHistoryActionKind)
      : eventType === 'SCAN'
        ? 'SCAN'
        : 'COMMAND';
  const rawStatus = String(data?.status || '').toUpperCase();
  const status: VulnerabilityHistoryStatus =
    rawStatus === 'FAILED' || rawStatus === 'INFO' || rawStatus === 'SUCCESS'
      ? (rawStatus as VulnerabilityHistoryStatus)
      : 'SUCCESS';
  const isLegacyScanSnapshot = !data?.eventType && Array.isArray(data?.findings);

  return {
    id,
    parentId: String(data?.parentId || ''),
    target,
    childId: data?.childId || undefined,
    childName: data?.childName || undefined,
    eventType: isLegacyScanSnapshot ? 'SCAN' : eventType,
    actionKind: isLegacyScanSnapshot ? 'SCAN' : actionKind,
    status: isLegacyScanSnapshot ? 'SUCCESS' : status,
    scanTimestamp: scanTs,
    scanTimestampMs: scanTsMs,
    riskScore: typeof data?.riskScore === 'number' ? data.riskScore : undefined,
    topSeverity: data?.topSeverity || undefined,
    severity: data?.severity || undefined,
    findingId: data?.findingId || undefined,
    titleEn: data?.titleEn || undefined,
    titleAr: data?.titleAr || undefined,
    summaryEn:
      data?.summaryEn ||
      (isLegacyScanSnapshot
        ? `Scan completed with risk score ${typeof data?.riskScore === 'number' ? data.riskScore : 0}`
        : undefined),
    summaryAr:
      data?.summaryAr ||
      (isLegacyScanSnapshot
        ? `اكتمل الفحص بدرجة مخاطر ${typeof data?.riskScore === 'number' ? data.riskScore : 0}`
        : undefined),
    command: data?.command || undefined,
    payload: data?.payload,
    undoAvailable: data?.undoAvailable === true || Boolean(data?.undoCommand),
    undoCommand: data?.undoCommand || undefined,
    undoPayload: data?.undoPayload,
    actor: data?.actor || undefined,
    metadata: data?.metadata && typeof data.metadata === 'object' ? data.metadata : undefined,
  };
};

export const deriveUndoCommandForChildAction = (
  command: string,
  payload: any
): UndoCommandInstruction | null => {
  const cmd = String(command || '').trim();
  if (!cmd) return null;

  if (cmd === 'dnsFiltering') {
    const current = payload && typeof payload === 'object' ? payload : {};
    const enabled = Boolean((current as any).enabled);
    return {
      command: 'dnsFiltering',
      payload: {
        ...current,
        enabled: !enabled,
        source: 'vulnerability_undo',
      },
    };
  }

  if (cmd === 'lockDevice') {
    const enabled = typeof payload === 'boolean' ? payload : Boolean((payload as any)?.enabled);
    return { command: 'lockDevice', payload: !enabled };
  }

  if (cmd === 'lockscreenBlackout') {
    const current = payload && typeof payload === 'object' ? payload : {};
    const enabled = Boolean((current as any).enabled);
    return {
      command: 'lockscreenBlackout',
      payload: {
        ...current,
        enabled: !enabled,
        message: enabled ? '' : current.message || '',
        source: 'vulnerability_undo',
      },
    };
  }

  if (cmd === 'walkieTalkieEnable') {
    const current = payload && typeof payload === 'object' ? payload : {};
    const enabled = Boolean((current as any).enabled);
    return {
      command: 'walkieTalkieEnable',
      payload: {
        ...current,
        enabled: !enabled,
        sourceTag: 'vulnerability_undo',
      },
    };
  }

  if (cmd === 'cutInternet') {
    const enabled = typeof payload === 'boolean' ? payload : Boolean((payload as any)?.enabled);
    return { command: 'cutInternet', payload: !enabled };
  }

  return null;
};

export const logParentVulnerabilityHistoryEvent = async (
  parentId: string,
  event: Omit<VulnerabilityHistoryEventInput, 'target'>
): Promise<void> => {
  if (!db || !parentId) return;
  await addDoc(
    collection(db, PARENT_FINDINGS_COLLECTION, parentId, HISTORY_SUBCOLLECTION),
    buildHistoryPayload(parentId, { ...event, target: 'PARENT' })
  );
};

export const logChildVulnerabilityHistoryEvent = async (
  parentId: string,
  childId: string,
  event: Omit<VulnerabilityHistoryEventInput, 'target' | 'childId'>
): Promise<void> => {
  if (!db || !parentId || !childId) return;
  await addDoc(
    collection(db, CHILD_FINDINGS_COLLECTION, childId, HISTORY_SUBCOLLECTION),
    buildHistoryPayload(parentId, { ...event, target: 'CHILD', childId })
  );
};

export const runParentDeviceVulnerabilityScan = async (
  parentId: string
): Promise<ParentVulnerabilityFinding[]> => {
  if (!parentId) return [];

  const findings: ParentVulnerabilityFinding[] = [];
  const nativeSurface = await scanParentAndroidSecuritySurface();
  const now = new Date();
  const secureContext = typeof window !== 'undefined' ? window.isSecureContext : true;
  const protocol = typeof window !== 'undefined' ? window.location.protocol : 'https:';
  const ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';

  if (nativeSurface.available && nativeSurface.result) {
    findings.push(...(nativeSurface.result.findings as ParentAndroidSecurityFinding[]));
  }

  if (!secureContext || protocol !== 'https:') {
    addFinding(findings, {
      id: 'PARENT_TRANSPORT_INSECURE',
      severity: 'CRITICAL',
      titleEn: 'Parent console is not running in fully secure context',
      titleAr: 'لوحة الوالدين لا تعمل ضمن سياق آمن بالكامل',
      detailEn:
        'Sensitive controls should run only over HTTPS secure context to reduce interception and session hijacking risk.',
      detailAr:
        'الأوامر الحساسة يجب أن تعمل فقط عبر HTTPS ضمن سياق آمن لتقليل خطر الاعتراض واختطاف الجلسة.',
      remediationMode: 'GUIDED',
      guidanceEn: 'Use HTTPS origin only and avoid public/open networks for privileged actions.',
      guidanceAr: 'استخدم دومين HTTPS فقط وتجنب الشبكات العامة عند تنفيذ إجراءات حساسة.',
    });
  }

  const browser = parseBrowserVersion(ua);
  const baseline: Record<string, number> = {
    chrome: 122,
    edge: 122,
    firefox: 123,
    safari: 17,
  };
  const required = baseline[browser.family];
  if (required && (browser.major ?? 0) < required) {
    addFinding(findings, {
      id: 'PARENT_BROWSER_OUTDATED',
      severity: 'HIGH',
      titleEn: 'Parent browser appears outdated',
      titleAr: 'متصفح الوالد يبدو قديماً',
      detailEn:
        `Detected ${browser.family} ${browser.major ?? 'unknown'}, below hardened baseline ${required}.`,
      detailAr:
        `تم رصد ${browser.family} ${browser.major ?? 'غير معروف'} وهو أقل من الحد الآمن ${required}.`,
      remediationMode: 'GUIDED',
      guidanceEn: 'Update browser to latest stable channel immediately.',
      guidanceAr: 'حدّث المتصفح إلى آخر إصدار مستقر فورًا.',
    });
  }

  try {
    const enabled = await is2FAEnabled(parentId);
    if (!enabled) {
      addFinding(findings, {
        id: 'PARENT_2FA_DISABLED',
        severity: 'HIGH',
        titleEn: 'Two-factor authentication is disabled',
        titleAr: 'المصادقة الثنائية غير مفعلة',
        detailEn: 'Disabling 2FA increases the blast radius of credential theft attacks.',
        detailAr: 'تعطيل 2FA يزيد أثر سرقة بيانات الدخول على الحساب.',
        remediationMode: 'GUIDED',
        guidanceEn: 'Enable TOTP-based 2FA and store backup recovery codes securely.',
        guidanceAr: 'فعّل 2FA عبر TOTP واحفظ أكواد الاستعادة الاحتياطية بأمان.',
      });
    }
  } catch {
    addFinding(findings, {
      id: 'PARENT_2FA_STATUS_UNKNOWN',
      severity: 'MEDIUM',
      titleEn: 'Unable to verify parent 2FA status',
      titleAr: 'تعذر التحقق من حالة 2FA للوالد',
      detailEn: '2FA status check failed, which may indicate auth/session or network issue.',
      detailAr: 'فشل التحقق من 2FA، وقد يدل على مشكلة جلسة أو اتصال.',
      remediationMode: 'GUIDED',
      guidanceEn: 'Re-authenticate parent account and verify 2FA configuration.',
      guidanceAr: 'أعد تسجيل الدخول وتأكد من إعدادات المصادقة الثنائية.',
    });
  }

  const externalWatchlist = await fetchExternalWatchlist();
  const activeWatchlist = externalWatchlist.length > 0 ? externalWatchlist : ZERO_DAY_WATCHLIST;

  const zeroDayExposureSignals = activeWatchlist.filter((item) =>
    item.platform === 'cross-platform' ||
    item.platform === 'browser' ||
    item.platform === 'android'
  ).slice(0, 5);
  if (zeroDayExposureSignals.length > 0) {
    addFinding(findings, {
      id: 'PARENT_ZERO_DAY_WATCH',
      severity: findings.some((f) => f.severity === 'CRITICAL') ? 'HIGH' : 'MEDIUM',
      titleEn: 'Active zero-day/zero-click watchlist requires patch discipline',
      titleAr: 'قائمة مراقبة zero-day/zero-click تتطلب انضباط تحديثات',
      detailEn: `Watchlist includes: ${zeroDayExposureSignals.map((s) => s.advisoryId).join(', ')}.`,
      detailAr: `القائمة الحالية تشمل: ${zeroDayExposureSignals.map((s) => s.advisoryId).join('، ')}.`,
      remediationMode: 'GUIDED',
      guidanceEn: 'Keep child Android patch level and parent browser fully updated every cycle.',
      guidanceAr: 'حافظ على تحديث تصحيح أندرويد للطفل ومتصفح الوالد باستمرار.',
    });
  }

  const riskScore = Math.min(
    100,
    findings.reduce((sum, item) => {
      if (item.severity === 'CRITICAL') return sum + 40;
      if (item.severity === 'HIGH') return sum + 26;
      if (item.severity === 'MEDIUM') return sum + 14;
      return sum + 6;
    }, 0)
  );

  if (db) {
    await setDoc(doc(db, PARENT_FINDINGS_COLLECTION, parentId), {
      parentId,
      scannedAt: Timestamp.now(),
      scannedAtMs: now.getTime(),
      browserFamily: browser.family,
      browserMajor: browser.major,
      secureContext,
      protocol,
      riskScore,
      findings,
      nativeScanAvailable: nativeSurface.available,
      nativeRiskScore: nativeSurface.result?.riskScore ?? null,
      deviceSummary: nativeSurface.result
        ? {
            apiLevel: nativeSurface.result.apiLevel,
            osVersion: nativeSurface.result.osVersion,
            securityPatchLevel: nativeSurface.result.securityPatchLevel,
            deviceModel: nativeSurface.result.deviceModel,
            isDeviceOwner: nativeSurface.result.isDeviceOwner,
          }
        : null,
      watchlist: zeroDayExposureSignals,
    });

    try {
      const topSeverity =
        findings.find((item) => item.severity === 'CRITICAL')?.severity ||
        findings.find((item) => item.severity === 'HIGH')?.severity ||
        findings.find((item) => item.severity === 'MEDIUM')?.severity ||
        findings[0]?.severity ||
        'LOW';

      await logParentVulnerabilityHistoryEvent(parentId, {
        eventType: 'SCAN',
        actionKind: 'SCAN',
        status: 'SUCCESS',
        scanTimestampMs: now.getTime(),
        riskScore,
        topSeverity,
        summaryEn: `Parent security scan completed (risk score ${riskScore}).`,
        summaryAr: `اكتمل فحص أمان جهاز الوالد (درجة المخاطر ${riskScore}).`,
        actor: nativeSurface.available ? 'PARENT_APP_NATIVE' : 'PARENT_APP_WEB',
        metadata: {
          findingsCount: findings.length,
          nativeScanAvailable: nativeSurface.available,
        },
      });
    } catch (historyError) {
      console.warn('[vulnerability] failed to log parent scan history:', historyError);
    }
  }

  return findings;
};

export const fetchChildVulnerabilityFindings = async (
  parentId: string
): Promise<DeviceVulnerabilityFindingRecord[]> => {
  if (!db || !parentId) return [];
  const q = query(collection(db, CHILD_FINDINGS_COLLECTION), where('parentId', '==', parentId));
  const snap = await getDocs(q);
  return snap.docs.map((d) => {
    const data = d.data() as any;
    return {
      childId: d.id,
      parentId: data.parentId,
      childName: data.childName || '',
      scanTimestamp: data.scanTimestamp?.toDate?.(),
      trigger: data.trigger,
      riskScore: data.riskScore,
      topSeverity: data.topSeverity,
      criticalCount: data.criticalCount,
      highCount: data.highCount,
      findings: Array.isArray(data.findings) ? data.findings : [],
    };
  });
};

export const subscribeToChildVulnerabilityFindings = (
  parentId: string,
  callback: (rows: DeviceVulnerabilityFindingRecord[]) => void
): (() => void) => {
  if (!db || !parentId) return () => {};
  const q = query(collection(db, CHILD_FINDINGS_COLLECTION), where('parentId', '==', parentId));
  return onSnapshot(q, (snap) => {
    const rows = snap.docs.map((d) => {
      const data = d.data() as any;
      return {
        childId: d.id,
        parentId: data.parentId,
        childName: data.childName || '',
        scanTimestamp: data.scanTimestamp?.toDate?.(),
        trigger: data.trigger,
        riskScore: data.riskScore,
        topSeverity: data.topSeverity,
        criticalCount: data.criticalCount,
        highCount: data.highCount,
        findings: Array.isArray(data.findings) ? data.findings : [],
      } as DeviceVulnerabilityFindingRecord;
    });
    callback(rows);
  });
};

export const subscribeToChildVulnerabilityHistory = (
  childId: string,
  callback: (rows: VulnerabilityHistoryEntry[]) => void,
  maxRows = 40
): (() => void) => {
  if (!db || !childId) return () => {};
  const q = query(
    collection(db, CHILD_FINDINGS_COLLECTION, childId, HISTORY_SUBCOLLECTION),
    orderBy('scanTimestampMs', 'desc'),
    limit(maxRows)
  );
  return onSnapshot(
    q,
    (snap) => {
      callback(snap.docs.map((docSnap) => mapHistoryEntry(docSnap.id, docSnap.data(), 'CHILD')));
    },
    (error) => {
      console.warn('[vulnerability] child history subscription failed:', error);
      callback([]);
    }
  );
};

export const subscribeToParentVulnerabilityHistory = (
  parentId: string,
  callback: (rows: VulnerabilityHistoryEntry[]) => void,
  maxRows = 40
): (() => void) => {
  if (!db || !parentId) return () => {};
  const q = query(
    collection(db, PARENT_FINDINGS_COLLECTION, parentId, HISTORY_SUBCOLLECTION),
    orderBy('scanTimestampMs', 'desc'),
    limit(maxRows)
  );
  return onSnapshot(
    q,
    (snap) => {
      callback(snap.docs.map((docSnap) => mapHistoryEntry(docSnap.id, docSnap.data(), 'PARENT')));
    },
    (error) => {
      console.warn('[vulnerability] parent history subscription failed:', error);
      callback([]);
    }
  );
};

const mapParentSnapshot = (parentId: string, data: any): ParentVulnerabilityScanSnapshot => ({
  parentId,
  scannedAt: data?.scannedAt?.toDate?.(),
  scannedAtMs: typeof data?.scannedAtMs === 'number' ? data.scannedAtMs : undefined,
  browserFamily: data?.browserFamily,
  browserMajor: typeof data?.browserMajor === 'number' ? data.browserMajor : null,
  secureContext: typeof data?.secureContext === 'boolean' ? data.secureContext : undefined,
  protocol: data?.protocol,
  riskScore: typeof data?.riskScore === 'number' ? data.riskScore : undefined,
  findings: Array.isArray(data?.findings) ? data.findings : [],
  nativeScanAvailable:
    typeof data?.nativeScanAvailable === 'boolean' ? data.nativeScanAvailable : undefined,
  nativeRiskScore: typeof data?.nativeRiskScore === 'number' ? data.nativeRiskScore : undefined,
  deviceSummary:
    data?.deviceSummary && typeof data.deviceSummary === 'object'
      ? {
          apiLevel:
            typeof data.deviceSummary.apiLevel === 'number' ? data.deviceSummary.apiLevel : undefined,
          osVersion:
            typeof data.deviceSummary.osVersion === 'string' ? data.deviceSummary.osVersion : undefined,
          securityPatchLevel:
            typeof data.deviceSummary.securityPatchLevel === 'string'
              ? data.deviceSummary.securityPatchLevel
              : undefined,
          deviceModel:
            typeof data.deviceSummary.deviceModel === 'string' ? data.deviceSummary.deviceModel : undefined,
          isDeviceOwner:
            typeof data.deviceSummary.isDeviceOwner === 'boolean'
              ? data.deviceSummary.isDeviceOwner
              : undefined,
        }
      : undefined,
  watchlist: Array.isArray(data?.watchlist) ? data.watchlist : [],
});

export const fetchParentVulnerabilityFindings = async (
  parentId: string
): Promise<ParentVulnerabilityScanSnapshot | null> => {
  if (!db || !parentId) return null;
  const snap = await getDoc(doc(db, PARENT_FINDINGS_COLLECTION, parentId));
  if (!snap.exists()) return null;
  return mapParentSnapshot(parentId, snap.data());
};

export const subscribeToParentVulnerabilityFindings = (
  parentId: string,
  callback: (row: ParentVulnerabilityScanSnapshot | null) => void
): (() => void) => {
  if (!db || !parentId) return () => {};
  return onSnapshot(doc(db, PARENT_FINDINGS_COLLECTION, parentId), (snap) => {
    if (!snap.exists()) {
      callback(null);
      return;
    }
    callback(mapParentSnapshot(parentId, snap.data()));
  });
};
