package com.amanah.child.services

import android.app.ActivityManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.provider.Settings
import android.util.Log
import com.google.firebase.Timestamp
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.TimeZone
import kotlin.math.min

class VulnerabilityScannerService : Service() {
    companion object {
        const val ACTION_SCAN_NOW = "com.amanah.child.action.SCAN_VULNERABILITIES_NOW"

        private const val TAG = "VulnScanner"
        private const val PREFS_NAME = "AmanahPrefs"
        private const val FINDINGS_COLLECTION = "vulnerabilityFindings"
        private const val FINDINGS_HISTORY_SUBCOLLECTION = "history"
        private const val ALERTS_COLLECTION = "alerts"
        private const val CHILDREN_COLLECTION = "children"
        private const val SCAN_INTERVAL_MS = 6 * 60 * 60 * 1000L
        private const val CRITICAL_ALERT_THROTTLE_MS = 4 * 60 * 60 * 1000L
        private const val PREF_LAST_CRITICAL_ALERT_AT = "vulnerabilityLastCriticalAlertAt"
    }

    private val db by lazy { FirebaseFirestore.getInstance() }
    private val scope = CoroutineScope(Dispatchers.IO)
    private var loopStarted = false

    override fun onCreate() {
        super.onCreate()
        startPeriodicLoopIfNeeded()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val action = intent?.action
        if (action == ACTION_SCAN_NOW) {
            scope.launch { runScan(trigger = "parent_manual_command") }
        } else {
            startPeriodicLoopIfNeeded()
        }
        return START_STICKY
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onDestroy() {
        scope.cancel()
        super.onDestroy()
    }

    private fun startPeriodicLoopIfNeeded() {
        if (loopStarted) return
        loopStarted = true
        scope.launch {
            while (isActive) {
                try {
                    runScan(trigger = "periodic")
                } catch (e: Exception) {
                    Log.w(TAG, "Periodic vulnerability scan failed: ${e.message}")
                }
                delay(SCAN_INTERVAL_MS)
            }
        }
    }

    private suspend fun runScan(trigger: String) {
        val prefs = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        val childId = prefs.getString("childDocumentId", null)
        val parentId = prefs.getString("parentId", null)
        if (childId.isNullOrBlank() || parentId.isNullOrBlank()) {
            return
        }

        val childName = prefs.getString("childName", "Child Device") ?: "Child Device"
        val findings = mutableListOf<Map<String, Any>>()
        val now = Timestamp.now()
        val nowMs = System.currentTimeMillis()

        val patchLagDays = getSecurityPatchLagDays()
        if (patchLagDays != null) {
            if (patchLagDays >= 120) {
                findings += finding(
                    id = "ANDROID_PATCH_LAG_CRITICAL",
                    severity = "CRITICAL",
                    titleEn = "Android security patch is heavily outdated",
                    titleAr = "تصحيح أمني قديم جدا على أندرويد",
                    detailEn = "Security patch lag is $patchLagDays days, increasing exposure to zero-click and zero-day exploit chains.",
                    detailAr = "تأخر التصحيح الأمني $patchLagDays يوم، ما يرفع التعرض لثغرات zero-click و zero-day.",
                    remediationMode = "GUIDED",
                    guidanceEn = "Update the device system security patch from Settings > System Update immediately.",
                    guidanceAr = "قم بتحديث تصحيحات أمان النظام من الإعدادات > تحديث النظام فورًا."
                )
            } else if (patchLagDays >= 60) {
                findings += finding(
                    id = "ANDROID_PATCH_LAG_HIGH",
                    severity = "HIGH",
                    titleEn = "Android security patch is outdated",
                    titleAr = "تصحيح أندرويد الأمني متأخر",
                    detailEn = "Patch lag is $patchLagDays days; this raises exploitability risk for recent vulnerabilities.",
                    detailAr = "التصحيح متأخر $patchLagDays يومًا، وهذا يرفع خطر الاستغلال للثغرات الحديثة.",
                    remediationMode = "GUIDED",
                    guidanceEn = "Install latest vendor OTA patch and restart device after update.",
                    guidanceAr = "ثبت آخر تحديث OTA من الشركة وأعد تشغيل الجهاز بعد التحديث."
                )
            }
        }

        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.Q) {
            findings += finding(
                id = "ANDROID_VERSION_OLD",
                severity = "HIGH",
                titleEn = "Android version is old",
                titleAr = "إصدار أندرويد قديم",
                detailEn = "Device API level is ${Build.VERSION.SDK_INT}. Older Android versions receive fewer mitigations for modern exploit chains.",
                detailAr = "مستوى API للجهاز هو ${Build.VERSION.SDK_INT}. الإصدارات القديمة تملك حماية أضعف ضد سلاسل الاستغلال الحديثة.",
                remediationMode = "GUIDED",
                guidanceEn = "Upgrade Android version to a currently supported release.",
                guidanceAr = "حدّث إصدار أندرويد إلى إصدار مدعوم حاليًا."
            )
        }

        val devOptions = isDeveloperOptionsEnabled()
        if (devOptions) {
            findings += finding(
                id = "DEVELOPER_OPTIONS_ENABLED",
                severity = "HIGH",
                titleEn = "Developer options are enabled",
                titleAr = "خيارات المطور مفعلة",
                detailEn = "Developer mode can increase attack surface when combined with physical access or social engineering.",
                detailAr = "وضع المطور قد يزيد سطح الهجوم خصوصًا مع الوصول الفيزيائي أو الهندسة الاجتماعية.",
                remediationMode = "GUIDED",
                guidanceEn = "Disable Developer Options unless needed for diagnostics.",
                guidanceAr = "عطّل خيارات المطور ما لم تكن مطلوبة للتشخيص."
            )
        }

        val adbEnabled = isAdbEnabled()
        if (adbEnabled) {
            findings += finding(
                id = "ADB_ENABLED",
                severity = "CRITICAL",
                titleEn = "USB debugging (ADB) is enabled",
                titleAr = "تصحيح USB (ADB) مفعل",
                detailEn = "ADB enables high-risk control channels that can be abused by malware or local attackers.",
                detailAr = "ADB يفتح قناة تحكم عالية الخطورة قد تستغلها برمجيات خبيثة أو مهاجم محلي.",
                remediationMode = "GUIDED",
                guidanceEn = "Disable USB debugging immediately from Developer Options.",
                guidanceAr = "قم بإيقاف USB Debugging فورًا من خيارات المطور."
            )
        }

        if (canInstallUnknownApps()) {
            findings += finding(
                id = "UNKNOWN_SOURCES_ALLOWED",
                severity = "HIGH",
                titleEn = "Unknown app installation is allowed",
                titleAr = "تثبيت التطبيقات من مصادر غير معروفة مسموح",
                detailEn = "Sideloading apps increases malware exposure outside trusted stores.",
                detailAr = "تثبيت التطبيقات من خارج المتاجر الموثوقة يزيد خطر البرمجيات الخبيثة.",
                remediationMode = "GUIDED",
                guidanceEn = "Disable unknown app install permission for all installers.",
                guidanceAr = "عطّل صلاحية التثبيت من مصادر غير معروفة لجميع أدوات التثبيت."
            )
        }

        val packageVerifierEnabled = isPackageVerifierEnabled()
        if (!packageVerifierEnabled) {
            findings += finding(
                id = "PACKAGE_VERIFIER_DISABLED",
                severity = "HIGH",
                titleEn = "Play Protect package verification appears disabled",
                titleAr = "فحص Play Protect للحزم يبدو معطلاً",
                detailEn = "Package verifier disabled state can reduce detection of malicious installs.",
                detailAr = "تعطيل فحص الحزم قد يقلل كشف التطبيقات الضارة عند التثبيت.",
                remediationMode = "GUIDED",
                guidanceEn = "Enable Google Play Protect and package verification.",
                guidanceAr = "فعّل Google Play Protect وفحص الحزم."
            )
        }

        if (isLikelyRooted()) {
            findings += finding(
                id = "ROOT_INDICATORS_PRESENT",
                severity = "CRITICAL",
                titleEn = "Root indicators detected",
                titleAr = "تم رصد مؤشرات Root",
                detailEn = "Root access greatly increases privilege-escalation and tampering risk.",
                detailAr = "الوصول بصلاحيات Root يرفع بشكل كبير خطر التصعيد والتلاعب.",
                remediationMode = "GUIDED",
                guidanceEn = "Reinstall official firmware and remove root tooling.",
                guidanceAr = "أعد تثبيت نظام رسمي للجهاز وأزل أدوات الروت."
            )
        }

        val accessibilityEnabled = isAmanahAccessibilityEnabled()
        if (!accessibilityEnabled) {
            findings += finding(
                id = "AMANAH_ACCESSIBILITY_DISABLED",
                severity = "HIGH",
                titleEn = "Amanah accessibility protection is disabled",
                titleAr = "حماية الوصول (Accessibility) في أمانة متوقفة",
                detailEn = "Disabling accessibility protection reduces policy enforcement for app and UI level risks.",
                detailAr = "إيقاف خدمة Accessibility يقلل تطبيق سياسات الحماية على مستوى التطبيق والواجهة.",
                remediationMode = "GUIDED",
                guidanceEn = "Open Accessibility settings and re-enable Amanah service.",
                guidanceAr = "افتح إعدادات Accessibility وأعد تفعيل خدمة Amanah."
            )
        }

        val dnsEnabled = prefs.getBoolean(DnsFilterVpnService.PREF_KEY_ENABLED, false)
        if (!dnsEnabled) {
            findings += finding(
                id = "DNS_FILTER_DISABLED",
                severity = "MEDIUM",
                titleEn = "DNS-level filtering is disabled",
                titleAr = "تصفية DNS غير مفعلة",
                detailEn = "Disabling DNS filtering lowers network-layer protection against malicious domains.",
                detailAr = "تعطيل تصفية DNS يخفض الحماية على مستوى الشبكة ضد النطاقات الضارة.",
                remediationMode = "AUTO",
                guidanceEn = "Parent can re-enable DNS filtering from command center.",
                guidanceAr = "يمكن للوالد إعادة تفعيل DNS filtering من مركز الأوامر.",
                autoCommand = mapOf(
                    "command" to "dnsFiltering",
                    "payload" to mapOf("enabled" to true, "mode" to "family", "domains" to emptyList<String>())
                )
            )
        }

        val offlineUnlockConfigured = prefs.getString("offlineUnlockTotpSecret", "").orEmpty().isNotBlank()
        if (!offlineUnlockConfigured) {
            findings += finding(
                id = "OFFLINE_UNLOCK_NOT_PROVISIONED",
                severity = "MEDIUM",
                titleEn = "Offline emergency unlock is not provisioned",
                titleAr = "فتح الطوارئ بدون إنترنت غير مهيأ",
                detailEn = "If connectivity is lost during lock mode, parents may not be able to unlock immediately.",
                detailAr = "عند فقد الاتصال أثناء القفل، قد لا يتمكن الوالدان من الفتح الفوري.",
                remediationMode = "GUIDED",
                guidanceEn = "Provision offline unlock from parent command panel.",
                guidanceAr = "قم بتهيئة Offline Unlock من لوحة أوامر الوالدين."
            )
        }

        val remoteServiceRunning = isRemoteCommandServiceRunning()
        if (!remoteServiceRunning) {
            findings += finding(
                id = "REMOTE_COMMAND_SERVICE_INACTIVE",
                severity = "HIGH",
                titleEn = "Remote command service appears inactive",
                titleAr = "خدمة الأوامر البعيدة تبدو غير نشطة",
                detailEn = "Command channel instability can delay emergency interventions.",
                detailAr = "تعطل قناة الأوامر قد يؤخر التدخلات الطارئة.",
                remediationMode = "AUTO",
                guidanceEn = "Service restart attempted automatically by child app.",
                guidanceAr = "يحاول التطبيق إعادة تشغيل الخدمة تلقائيًا.",
                autoCommand = mapOf(
                    "action" to "restartService",
                    "service" to "RemoteCommandService"
                )
            )
        }

        val severityWeight = mapOf(
            "LOW" to 8,
            "MEDIUM" to 16,
            "HIGH" to 28,
            "CRITICAL" to 42
        )
        val riskScore = min(
            100,
            findings.sumOf { severityWeight[(it["severity"] as? String) ?: "LOW"] ?: 8 }
        )
        val criticalCount = findings.count { it["severity"] == "CRITICAL" }
        val highCount = findings.count { it["severity"] == "HIGH" }
        val topSeverity = when {
            criticalCount > 0 -> "CRITICAL"
            highCount > 0 -> "HIGH"
            findings.any { it["severity"] == "MEDIUM" } -> "MEDIUM"
            findings.isNotEmpty() -> "LOW"
            else -> "SAFE"
        }

        val payload = hashMapOf<String, Any>(
            "childId" to childId,
            "parentId" to parentId,
            "childName" to childName,
            "trigger" to trigger,
            "scanTimestamp" to now,
            "scanTimestampMs" to nowMs,
            "deviceModel" to "${Build.MANUFACTURER} ${Build.MODEL}",
            "osVersion" to "Android ${Build.VERSION.RELEASE}",
            "apiLevel" to Build.VERSION.SDK_INT,
            "securityPatchLevel" to (Build.VERSION.SECURITY_PATCH ?: ""),
            "patchLagDays" to (patchLagDays ?: -1),
            "riskScore" to riskScore,
            "topSeverity" to topSeverity,
            "criticalCount" to criticalCount,
            "highCount" to highCount,
            "findings" to findings,
            "scannerVersion" to "v1.0.0"
        )

        db.collection(FINDINGS_COLLECTION).document(childId)
            .set(payload)
            .addOnFailureListener { e ->
                Log.w(TAG, "Failed to write vulnerability snapshot: ${e.message}")
            }

        db.collection(FINDINGS_COLLECTION).document(childId)
            .collection(FINDINGS_HISTORY_SUBCOLLECTION)
            .add(payload)
            .addOnFailureListener { e ->
                Log.w(TAG, "Failed to append vulnerability history: ${e.message}")
            }

        db.collection(CHILDREN_COLLECTION).document(childId)
            .update(
                hashMapOf(
                    "lastVulnerabilityScanAt" to now,
                    "vulnerabilityRiskScore" to riskScore,
                    "vulnerabilityTopSeverity" to topSeverity
                ) as Map<String, Any>
            )
            .addOnFailureListener { e ->
                Log.w(TAG, "Failed to sync child vulnerability summary: ${e.message}")
            }

        maybeEmitCriticalAlert(
            prefs = prefs,
            parentId = parentId,
            childId = childId,
            childName = childName,
            findings = findings
        )
    }

    private fun finding(
        id: String,
        severity: String,
        titleEn: String,
        titleAr: String,
        detailEn: String,
        detailAr: String,
        remediationMode: String,
        guidanceEn: String,
        guidanceAr: String,
        autoCommand: Map<String, Any>? = null
    ): Map<String, Any> {
        val payload = hashMapOf<String, Any>(
            "id" to id,
            "severity" to severity,
            "titleEn" to titleEn,
            "titleAr" to titleAr,
            "detailEn" to detailEn,
            "detailAr" to detailAr,
            "remediationMode" to remediationMode,
            "guidanceEn" to guidanceEn,
            "guidanceAr" to guidanceAr
        )
        if (autoCommand != null) {
            payload["autoCommand"] = autoCommand
        }
        return payload
    }

    private fun maybeEmitCriticalAlert(
        prefs: android.content.SharedPreferences,
        parentId: String,
        childId: String,
        childName: String,
        findings: List<Map<String, Any>>
    ) {
        val critical = findings.filter { it["severity"] == "CRITICAL" }
        if (critical.isEmpty()) return

        val now = System.currentTimeMillis()
        val lastAlertAt = prefs.getLong(PREF_LAST_CRITICAL_ALERT_AT, 0L)
        if (now - lastAlertAt < CRITICAL_ALERT_THROTTLE_MS) return
        prefs.edit().putLong(PREF_LAST_CRITICAL_ALERT_AT, now).apply()

        val topSignals = critical.take(3).mapNotNull { it["titleEn"] as? String }
        val summary = if (topSignals.isNotEmpty()) topSignals.joinToString("; ") else "Critical vulnerability posture"

        val alert = hashMapOf<String, Any>(
            "parentId" to parentId,
            "childId" to childId,
            "childName" to childName,
            "platform" to "Device Vulnerability Scanner",
            "content" to "Critical device vulnerability posture detected: $summary",
            "category" to "TAMPER",
            "severity" to "CRITICAL",
            "timestamp" to Timestamp.now(),
            "status" to "NEW",
            "aiAnalysis" to "On-device vulnerability scanner flagged critical exploitability indicators (zero-click/zero-day exposure risk).",
            "actionTaken" to "Guided and automatic remediation options attached in vulnerability findings."
        )
        db.collection(ALERTS_COLLECTION).add(alert)
            .addOnFailureListener { e ->
                Log.w(TAG, "Failed to publish critical vulnerability alert: ${e.message}")
            }
    }

    private fun getSecurityPatchLagDays(): Int? {
        val patch = Build.VERSION.SECURITY_PATCH ?: return null
        if (patch.isBlank()) return null
        return try {
            val parser = SimpleDateFormat("yyyy-MM-dd", Locale.US).apply {
                timeZone = TimeZone.getTimeZone("UTC")
            }
            val patchDate = parser.parse(patch) ?: return null
            val diffMs = System.currentTimeMillis() - patchDate.time
            (diffMs / (24L * 60L * 60L * 1000L)).toInt().coerceAtLeast(0)
        } catch (_: Exception) {
            null
        }
    }

    private fun isDeveloperOptionsEnabled(): Boolean {
        return try {
            Settings.Global.getInt(contentResolver, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) == 1
        } catch (_: Exception) {
            false
        }
    }

    private fun isAdbEnabled(): Boolean {
        return try {
            Settings.Global.getInt(contentResolver, Settings.Global.ADB_ENABLED, 0) == 1
        } catch (_: Exception) {
            false
        }
    }

    private fun canInstallUnknownApps(): Boolean {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                packageManager.canRequestPackageInstalls()
            } else {
                @Suppress("DEPRECATION")
                Settings.Secure.getInt(contentResolver, Settings.Secure.INSTALL_NON_MARKET_APPS, 0) == 1
            }
        } catch (_: Exception) {
            false
        }
    }

    private fun isPackageVerifierEnabled(): Boolean {
        return try {
            val packageVerifier = Settings.Global.getInt(contentResolver, "package_verifier_enable", 1) == 1
            val adbVerifier = Settings.Global.getInt(contentResolver, "verifier_verify_adb_installs", 1) == 1
            packageVerifier && adbVerifier
        } catch (_: Exception) {
            true
        }
    }

    private fun isLikelyRooted(): Boolean {
        if ((Build.TAGS ?: "").contains("test-keys", ignoreCase = true)) return true

        val suspiciousPaths = listOf(
            "/system/app/Superuser.apk",
            "/sbin/su",
            "/system/bin/su",
            "/system/xbin/su",
            "/data/local/xbin/su",
            "/data/local/bin/su",
            "/system/sd/xbin/su",
            "/system/bin/failsafe/su",
            "/data/local/su"
        )
        if (suspiciousPaths.any { File(it).exists() }) return true

        return try {
            Runtime.getRuntime().exec(arrayOf("/system/xbin/which", "su")).inputStream.bufferedReader().use {
                it.readLine() != null
            }
        } catch (_: Exception) {
            false
        }
    }

    private fun isAmanahAccessibilityEnabled(): Boolean {
        val serviceName = "${packageName}/${AmanahAccessibilityService::class.java.canonicalName}"
        val enabledServices = Settings.Secure.getString(
            contentResolver,
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        ) ?: return false
        return enabledServices.contains(serviceName, ignoreCase = true)
    }

    private fun isRemoteCommandServiceRunning(): Boolean {
        return try {
            val manager = getSystemService(Context.ACTIVITY_SERVICE) as? ActivityManager ?: return false
            @Suppress("DEPRECATION")
            manager.getRunningServices(Int.MAX_VALUE).any { info ->
                info.service.className == RemoteCommandService::class.java.name
            }
        } catch (_: Exception) {
            false
        }
    }
}
